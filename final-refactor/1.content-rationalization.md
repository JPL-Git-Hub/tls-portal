# Content Rationalization Guide

## Purpose
Audit and clean up documentation content BEFORE file classification to eliminate redundant, outdated, or conflicting information within documents.

## Phase 1: Documentation Inventory

### 1.1 List All Documentation
```bash
find . -name "*.md" -not -path "./node_modules/*" | sort > docs-inventory.txt
```

### 1.2 Categorize Documentation
- **Setup/Installation docs** - README.md, setup guides, prerequisites
- **Development docs** - Development guides, workflow docs  
- **Architecture docs** - Tech stack, deployment strategy, design decisions
- **Reference docs** - API docs, configuration guides, troubleshooting
- **Process docs** - Scripts, testing, compliance guides

## Phase 1.5: Essential Git History Analysis (30 minutes max)

### 1.5.1 Identify Major Changes
```bash
# Find replacement/migration commits
git log --oneline --grep="replace\|remove\|deprecate\|migrate" --since="1 year ago"

# Find deleted files (superseded approaches)
git log --diff-filter=D --summary --since="6 months ago" | grep delete

# Find heavy rewrites (evolved approaches)
git log --stat --since="6 months ago" | grep -E "\|.*\+.*-" | head -10
```

### 1.5.2 Prioritize Files by Change Activity
```bash
# Identify files with most changes (focus refactoring here)
git log --name-only --pretty=format: | sort | uniq -c | sort -nr | head -20

# Find files that haven't changed much (minimal refactoring needed)
git log --name-only --since="6 months ago" --pretty=format: | sort | uniq -c | sort -n | head -20
```

**Refactoring Priority:**
- **High priority**: Files with 10+ commits, multiple contributors, or recent major changes
- **Medium priority**: Files with 3-10 commits or moderate evolution  
- **Low priority**: Files with 1-2 commits that haven't changed significantly

### 1.5.3 Document Evolution Context
Create simple `evolution-notes.md` with:
- **Superseded approaches** - What was replaced and why
- **Deprecated tools** - Software/methods no longer used
- **Failed experiments** - Approaches that were tried and abandoned
- **Major rewrites** - When approaches fundamentally changed
- **High-change files** - List of files needing focused refactoring attention
- **Outdated technical claims** - Documentation that doesn't match current implementation

## Phase 2: Content Audit (Focus on High-Change Files)

### 2.1 Identify Redundant Content
**Prioritize files with high git activity** (from Phase 1.5.2). For these files, check for:
- **Duplicate setup instructions** across multiple files
- **Repeated explanations** of same concepts
- **Multiple versions** of same procedure
- **Overlapping scope** between documents

**Low-change files typically need minimal audit** - scan quickly for obvious issues only.

### 2.2 Find Outdated Content
Using evolution notes and focusing on **high-priority files**, look for references to:
- **Deprecated tools** - Old versions, replaced software
- **Outdated commands** - Changed CLI syntax, removed options
- **Dead links** - Broken external references
- **Obsolete approaches** - Superseded methodologies
- **Version-specific info** - Hard-coded version numbers that are now old

### 2.3 Identify Inaccurate Technical Claims
**Cross-reference documentation with actual implementation** for high-change files:
- **Custom vs standard libraries** - Claims of "custom utilities" that are actually standard libraries
- **Implementation approaches** - Documented methods that don't match current code
- **Feature descriptions** - Claimed functionality that was replaced or removed
- **Architecture descriptions** - System design claims that evolved

**Example patterns to check:**
```bash
# Find claims about custom implementations in docs
grep -r "custom.*validation\|custom.*utility\|custom.*helper" docs/

# Look for specific technical claims that might be outdated
grep -r "we built\|we created\|custom.*solution" docs/

# Check actual source files for patterns (exclude node_modules)
find src -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" | \
  grep -v node_modules | \
  xargs grep -l "TODO\|FIXME\|HACK\|workaround" 2>/dev/null
```

### 2.4 Detect Conflicting Instructions
**Focus on files that evolved significantly**. Check for:
- **Different procedures** for same task across docs
- **Contradictory requirements** - Different prerequisite lists
- **Inconsistent naming** - Same concept called different things
- **Conflicting recommendations** - Different "best practices" for same scenario

## Phase 3: Content Validation

### 3.1 Test All Procedures
For each documented procedure:
- [ ] Follow instructions exactly as written
- [ ] Note any steps that fail or produce errors
- [ ] Identify missing prerequisites
- [ ] Check if output matches expectations

### 3.2 Verify External References
- [ ] Test all external links (tools, documentation, resources)
- [ ] Check software version requirements are current
- [ ] Validate download links and installation instructions
- [ ] Confirm API documentation is current

### 3.3 Cross-Reference Check
- [ ] Compare related documents for consistency
- [ ] Verify shared concepts use same terminology
- [ ] Check that prerequisites are consistently listed
- [ ] Ensure workflow steps align across documents

## Phase 4: Content Cleanup

### 4.1 Consolidation Strategy
- **Merge redundant sections** - Combine duplicate explanations into single source
- **Create authoritative version** - Designate one document as canonical for each topic
- **Cross-reference instead of duplicate** - Link to authoritative version rather than repeat
- **Extract common sections** - Move shared content to dedicated files

### 4.2 Update Outdated Content
- **Remove deprecated approaches** - Delete sections about obsolete methods
- **Update tool references** - Current versions, installation methods
- **Fix broken procedures** - Correct steps that no longer work
- **Refresh examples** - Update code examples to current syntax

### 4.3 Resolve Conflicts
- **Choose current approach** - Keep most recent/effective method
- **Document decisions** - Note why one approach was chosen over another
- **Remove conflicting alternatives** - Don't leave multiple options without guidance
- **Update cross-references** - Fix links to consolidated content

## Phase 5: Content Organization

### 5.1 Establish Document Hierarchy
- **Primary docs** - Essential information, frequently referenced
- **Secondary docs** - Supporting information, specific use cases
- **Reference docs** - Quick lookup, rarely read end-to-end
- **Archive docs** - Historical information, kept for reference only

### 5.2 Improve Navigation
- **Update table of contents** - Reflect current document structure
- **Fix internal links** - Point to consolidated content
- **Add cross-references** - Link related concepts across documents
- **Create document index** - Master list of what's documented where

## Phase 6: Validation

### 6.1 Fresh Reader Test
- [ ] Have someone unfamiliar follow setup instructions
- [ ] Note any confusion or missing steps
- [ ] Verify all procedures work as documented
- [ ] Check that document flow makes sense

### 6.2 Consistency Check
- [ ] Same terminology used throughout
- [ ] Consistent formatting and structure
- [ ] No contradictory instructions remain
- [ ] All cross-references work correctly

## Rationalization Checklist

### Content Quality
- [ ] No duplicate procedures across documents
- [ ] No outdated tool references or commands
- [ ] No broken external links
- [ ] No conflicting instructions for same task
- [ ] All documented procedures tested and working
- [ ] Technical claims match actual implementation
- [ ] No false claims about "custom" solutions that use standard libraries

### Organization Quality  
- [ ] Clear document hierarchy established
- [ ] Redundant content consolidated
- [ ] Cross-references updated and working
- [ ] Navigation improved and accurate

### Maintenance Quality
- [ ] Document ownership/authority clarified
- [ ] Update process for each document type defined
- [ ] Version/date information current
- [ ] Archive strategy for obsolete content established

## Output Artifacts

After rationalization:
- **Updated documentation** - Clean, non-redundant content
- **Consolidation log** - Record of what was merged/removed
- **Evolution notes** - Historical context for major changes
- **Technical accuracy corrections** - List of inaccurate claims fixed
- **Document map** - What information lives where

## Example Evolution Notes Template

```markdown
# Evolution Notes

## Superseded Approaches
- Initial custom auth → Firebase Auth integration
- Manual validation → React Hook Form + Zod

## Deprecated Tools  
- Webpack → Vite (build tool change)
- Custom form validation → React Hook Form

## Outdated Technical Claims Found
- "Custom address validation utilities" → Actually using React Hook Form + Zod
- "Custom subdomain routing" → Actually using express-subdomain package
- [Add other inaccuracies found during audit]

## High-Change Files (Focus Refactoring Here)
- src/auth/authentication.ts (15 commits)
- docs/setup-guide.md (12 commits)
- [Files with 10+ commits or major changes]
```

## Integration with File Classification

After content rationalization is complete:
1. Proceed to file classification using clean documentation as "B" (Keep) files
2. Use consolidation log to avoid re-creating redundant content
3. Reference document map during pattern extraction to avoid duplication

## Time Estimate
- Small project (5-10 docs): 1-2 hours
- Medium project (10-20 docs): 2-3 hours  
- Large project (20+ docs): 3-4 hours

**Note: Time estimates assume focusing effort on high-change files identified in git analysis. Stable files need minimal attention.**

## Notes
- Complete this BEFORE file classification
- Focus on content quality, not file organization
- Document all changes for transparency
- Test everything after rationalization